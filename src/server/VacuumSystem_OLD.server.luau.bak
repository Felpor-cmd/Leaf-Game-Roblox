-- VacuumSystem.server.luau
-- Sistema de transforma√ß√£o e aspira√ß√£o de folhas

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- Configura√ß√µes do sistema
local VACUUM_RANGE = 20 -- Dist√¢ncia m√°xima para aspirar folhas
local VACUUM_FORCE = 50 -- For√ßa de atra√ß√£o das folhas
local DETECTION_ANGLE = 120 -- √Çngulo de detec√ß√£o frontal (graus)
local VACUUM_UPDATE_RATE = 0.1 -- Atualiza aspira√ß√£o a cada 0.1 segundos (10 FPS ao inv√©s de 60 FPS)

-- Vari√°veis de controle
local playersWithVacuum = {} -- Tabela para rastrear jogadores com poder
local vacuumConnections = {} -- Conex√µes dos loops de aspira√ß√£o
local lastVacuumUpdate = {} -- √öltima atualiza√ß√£o para cada jogador
local cachedLeaves = {} -- Cache de folhas para evitar busca constante

-- Refer√™ncias
local transformWall = workspace:WaitForChild("TransformWall")

-- Fun√ß√£o para atualizar cache de folhas (executa menos frequentemente)
local function updateLeavesCache()
    cachedLeaves = {}
    
    for _, obj in pairs(workspace:GetChildren()) do
        -- Verifica se √© uma folha spawnnada
        if obj.Name:find("SpawnedLeaf_") and (obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("Model")) then
            table.insert(cachedLeaves, obj)
        end
    end
end

-- Atualiza cache a cada 0.5 segundos
spawn(function()
    while true do
        updateLeavesCache()
        wait(0.5) -- Cache atualizado 2 vezes por segundo
    end
end)

-- Fun√ß√£o para verificar se a folha est√° na frente do jogador
local function isLeafInFront(character, leaf)
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local playerPosition = humanoidRootPart.Position
    local playerLookDirection = humanoidRootPart.CFrame.LookVector
    local leafPosition = leaf.Position
    
    -- Vetor da posi√ß√£o do jogador para a folha
    local toLeaf = (leafPosition - playerPosition).Unit
    
    -- Calcula o √¢ngulo entre a dire√ß√£o do olhar e a dire√ß√£o da folha
    local dotProduct = playerLookDirection:Dot(toLeaf)
    local angle = math.deg(math.acos(math.clamp(dotProduct, -1, 1)))
    
    -- Debug: mostra informa√ß√µes do √¢ngulo
    if angle <= DETECTION_ANGLE / 2 then
        print("Folha detectada na frente! √Çngulo:", math.floor(angle), "graus")
        return true
    end
    
    return false
end

-- Fun√ß√£o para aspirar folhas
local function vacuumLeaves(player)
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local leavesFound = 0
    local leavesInRange = 0
    local leavesInFront = 0
    local totalObjects = 0
    local debugObjects = {}
    
    -- Busca por folhas spawnnadas no workspace
    for _, obj in pairs(workspace:GetChildren()) do
        totalObjects = totalObjects + 1
        
        -- Debug: adiciona nome do objeto para an√°lise
        if obj.Name:find("Leaf") or obj.Name:find("Spawn") then
            table.insert(debugObjects, obj.Name)
        end
        
        -- Verifica se √© uma folha spawnnada (detec√ß√£o mais ampla)
        local isLeaf = false
        local debugReason = ""
        
        if obj.Name:find("SpawnedLeaf_") then
            isLeaf = true
            debugReason = "Nome SpawnedLeaf_"
        elseif obj:IsA("Part") and obj:FindFirstChild("LeafTag") then
            isLeaf = true
            debugReason = "Part com LeafTag"
        elseif obj:IsA("MeshPart") and obj:FindFirstChild("LeafTag") then
            isLeaf = true
            debugReason = "MeshPart com LeafTag"
        elseif obj:IsA("Model") and obj.Name:find("SpawnedLeaf_") then
            isLeaf = true
            debugReason = "Model SpawnedLeaf_"
        elseif (obj:IsA("Part") or obj:IsA("MeshPart")) and obj.Name:find("Leaf") and obj.Parent == workspace then
            isLeaf = true
            debugReason = "Part/MeshPart com 'Leaf' no nome"
        end
        
        if isLeaf and (obj:IsA("Part") or obj:IsA("Model") or obj:IsA("MeshPart")) then
            leavesFound = leavesFound + 1
            print("‚úÖ FOLHA DETECTADA:", obj.Name, "| Tipo:", obj.ClassName, "| Raz√£o:", debugReason)
            
            -- Para Models, pega a PrimaryPart ou primeira Part/MeshPart
            local leafPart = obj
            if obj:IsA("Model") then
                leafPart = obj.PrimaryPart or obj:FindFirstChildOfClass("Part") or obj:FindFirstChildOfClass("MeshPart")
            end
            
            if leafPart then
                local distance = (leafPart.Position - humanoidRootPart.Position).Magnitude
                
                print("ÔøΩ Dist√¢ncia da folha:", math.floor(distance), "| Ancorada:", leafPart.Anchored, "| Posi√ß√£o:", leafPart.Position)
                
                -- Verifica se est√° no alcance
                if distance <= VACUUM_RANGE then
                    leavesInRange = leavesInRange + 1
                    print("üéØ Folha no alcance!")
                    
                    -- Verifica se est√° na frente do jogador
                    if isLeafInFront(character, leafPart) then
                        leavesInFront = leavesInFront + 1
                        print("üå™Ô∏è Aspirando folha a", math.floor(distance), "studs de dist√¢ncia")
                        
                        -- Remove qualquer f√≠sica existente
                        for _, child in pairs(leafPart:GetChildren()) do
                            if child:IsA("BodyVelocity") or child:IsA("BodyAngularVelocity") then
                                child:Destroy()
                            end
                        end
                        
                        -- For√ßa desancoragem
                        leafPart.Anchored = false
                        leafPart.CanCollide = false
                        
                        -- Cria nova for√ßa de atra√ß√£o
                        local bodyVelocity = Instance.new("BodyVelocity")
                        bodyVelocity.Name = "VacuumForce"
                        bodyVelocity.MaxForce = Vector3.new(10000, 10000, 10000)
                        
                        -- Calcula dire√ß√£o para o jogador
                        local direction = (humanoidRootPart.Position - leafPart.Position).Unit
                        local force = VACUUM_FORCE * 2
                        
                        bodyVelocity.Velocity = direction * force
                        bodyVelocity.Parent = leafPart
                        
                        print("üí® For√ßa aplicada:", force, "| Dire√ß√£o:", direction)
                        
                        -- Se a folha est√° muito pr√≥xima, coleta ela
                        if distance < 5 then
                            print("‚úÖ Jogador", player.Name, "aspirou uma folha!")
                            obj:Destroy()
                        end
                    else
                        print("‚ùå Folha n√£o est√° na frente do jogador")
                    end
                else
                    print("‚ùå Folha fora do alcance:", math.floor(distance), "/", VACUUM_RANGE)
                end
            end
        end
    end
    
    -- Debug a cada 3 segundos
    if tick() % 3 < 0.017 then
        print("üîç Debug:", player.Name, "- Total objetos:", totalObjects, "| Folhas:", leavesFound, "| Alcance:", leavesInRange, "| Frente:", leavesInFront)
        print("üóÇÔ∏è Objetos com 'Leaf':", table.concat(debugObjects, ", "))
    end
end

-- Fun√ß√£o para dar poderes de aspirador ao jogador
local function giveVacuumPower(player)
    if playersWithVacuum[player] then return end -- J√° tem o poder
    
    playersWithVacuum[player] = true
    print("üå™Ô∏è Jogador", player.Name, "ganhou poderes de aspirador!")
    
    -- Efeito visual no jogador (opcional)
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Adiciona um efeito visual
            local attachment = Instance.new("Attachment")
            attachment.Name = "VacuumEffect"
            attachment.Parent = humanoidRootPart
            
            -- Aqui voc√™ pode adicionar ParticleEmitter ou outros efeitos visuais
        end
    end
    
    -- Inicia o loop de aspira√ß√£o para este jogador
    vacuumConnections[player] = RunService.Heartbeat:Connect(function()
        if playersWithVacuum[player] then -- Verifica se ainda tem o poder
            vacuumLeaves(player)
        end
    end)
end

-- Fun√ß√£o para remover poderes de aspirador do jogador
local function removeVacuumPower(player)
    if not playersWithVacuum[player] then return end -- N√£o tem o poder
    
    playersWithVacuum[player] = nil
    print("Jogador", player.Name, "perdeu poderes de aspirador!")
    
    -- Remove efeito visual
    local character = player.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local effect = humanoidRootPart:FindFirstChild("VacuumEffect")
            if effect then
                effect:Destroy()
            end
        end
    end
    
    -- Para o loop de aspira√ß√£o
    if vacuumConnections[player] then
        vacuumConnections[player]:Disconnect()
        vacuumConnections[player] = nil
    end
end

-- Fun√ß√£o para detectar passagem pela parede
local function onWallTouch(hit, player)
    local character = hit.Parent
    local humanoid = character:FindFirstChild("Humanoid")
    
    if humanoid and player then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        -- Determina de que lado da parede o jogador est√°
        local wallPosition = transformWall.Position
        local playerPosition = humanoidRootPart.Position
        
        -- Assume que a parede est√° orientada no eixo X
        -- Lado esquerdo (X menor) = sem poder, Lado direito (X maior) = com poder
        local isOnPowerSide = playerPosition.X > wallPosition.X
        
        if isOnPowerSide and not playersWithVacuum[player] then
            -- Jogador entrou no lado do poder
            giveVacuumPower(player)
        elseif not isOnPowerSide and playersWithVacuum[player] then
            -- Jogador saiu do lado do poder
            removeVacuumPower(player)
        end
    end
end

-- Conecta eventos de toque na parede
transformWall.Touched:Connect(function(hit)
    local player = Players:GetPlayerFromCharacter(hit.Parent)
    if player then
        onWallTouch(hit, player)
    end
end)

-- Limpeza quando jogador sai do jogo
Players.PlayerRemoving:Connect(function(player)
    if vacuumConnections[player] then
        vacuumConnections[player]:Disconnect()
        vacuumConnections[player] = nil
    end
    playersWithVacuum[player] = nil
end)

print("VacuumSystem iniciado! TransformWall detectar√° jogadores para dar/remover poderes de aspirador.")
print("Alcance do aspirador:", VACUUM_RANGE, "studs | √Çngulo frontal:", DETECTION_ANGLE, "graus")
